# 响应式系统的作用与实现

## 响应式数据与副作用函数

副作用函数指的是会产生副作用的函数，执行会直接或者间接影响其他函数的执行。

```js
function effect() {
  document.body.innerText = 'hello vue3'
  // 除了effect外任何函数都可以读取document，因此这是副作用函数。
}
```

```js
const obj = { text: 'hello vue3' }
function effect() {
  documemt.body.innerText = obj.text
}
// 修改obj.text的值，同时希望副作用重新执行
obj.text = 'hello world'
```

响应式数据指的是数据变化后，能够自动执行副作用函数。

## 响应式数据基本实现

- 当副作用函数执行时，会触发字段 obj.text 的**读取**操作 -> 存储副作用函数 effect
- 当修改 obj.text 的值时，会触发字段 obj.text 的**设置**操作 -> 取出副作用函数 effect 并执行

Vue2 采用的是 Object.defineProperty,Vue3 则使用了 Proxy 代理对象实现：

```js
// 存储副作用函数
const bucket = new Set()
// 原始数据
const data = { text: 'hello world' }
// 对原始数据代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 存储副作用函数
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用集合取出来并执行
    bucket.forEach((fn) => fn())
    // 返回true代表设置成功
    return true
  },
})
```

## 设计一个完善的响应式系统

上面的代码存在以下问题：

- 副作用函数必须是 effect 命名。
  需要不管副作用是其他命名甚至匿名函数都能够生效。定义一个 `activeEffect `全局变量存储当前副作用函数。
- 响应式数据设置不存在属性时，副作用函数依旧执行。
  在副作用函数和响应式对象属性间建立明确的联系。采用 WeakMap (target : depsMap), Map (key: Set)存储结构建立联系。

![WeakMap、Map和Set之间的关系](https://cdn.jsdelivr.net/gh/mipaifu328/image@master/study/Vue3-WeakMap-Map-Set.15um3nsb7fng.webp)

```js
// 存储副作用函数的‘桶’
const bucket = new WeakMap()
// 全局变量用来存储被注册的副作用函数
let activeEffect

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 没有activeEffect， 直接return
    if (!activeEffect) return
    // 根据target从”桶“中取得depsMap,它也是Map类型： key->effects
    let depsMap = bucket.get(target)
    // 如果不存在，则新建一个Map并与target关联
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()))
    }
    // 再根据key 从 depsMap中获取deps， 它是一个Set类型，
    // 里面存储了所有与key相关联的副作用函数： effects
    let deps = depsMap.get(key)
    if (!deps) {
      depsMap.set(key, (deps = new Set()))
    }
    // 将当前激活的副作用函数添加到”桶“里
    deps.add(activeEffect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 根据target找到对应的depsMap, key -> effects
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 根据key取得所有副作用函数effects
    const effects = depsMap.get(key)
    // 执行副作用函数
    effects && effects.forEach((fn) => fn())
    // 返回true代表设置成功
    return true
  },
})

function effect(fn) {
  // 当调用effect注册副作用函数时，将副作用函数fn赋值给activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}
```

解释下为什么使用 weakMap：
**WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。** 一旦 key 被来垃圾回收器回收，那么对应的键和值就访问不到。**如果使用 Map 代替 WeakMap，那么即使用户的代码对 target 没有任何引用了，这个 target 也不会被回收，最终可能导致内存溢出。**

## 分支切换与 cleanup

分支切换： 代码会根据不同条件发生变化。

```js
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, {
  /* ... */
})

effect(function effectFn() {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```

当 obj.ok = true, 副作用函数 effectFn 与响应数据之间建立的联系为:

```
data -ok - effectFn
     -text - effectFn
```

当 obj.ok = false 时，副作用函数理论上应该只剩下 data.ok 修改才会触发 effectFn。但以目前实现，遗留的副作用函数会导致不必要的更新（修改 obj.text 会导致副作用函数被触发）。

**解决思路：副作用函数和依赖集合建立关联，每次副作用执行前，将其从相关联的依赖集合中移除。**

```js
let activeEffect

function effect(fn) {
  // 当effectFn执行时，将其设置为当前激活的副作用函数
  const effectFn = () => {
    // 调用cleanup函数清除遗留依赖
    cleanup(effectFn)
    activeEffect = effectFn
    fn()
  }
  // activeEffect.deps用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = [] // 副作用最初执行一次，后续调用的是effectFn
  effectFn()
}

function track(target, key) {
  // 没有activeEffect， 直接return
  if (!activeEffect) return
  // 根据target从”桶“中取得depsMap,它也是Map类型： key->effects
  let depsMap = bucket.get(target)
  // 如果不存在，则新建一个Map并与target关联
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据key 从 depsMap中获取deps， 它是一个Set类型，
  // 里面存储了所有与key相关联的副作用函数： effects
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 将当前激活的副作用函数添加到”桶“里
  deps.add(activeEffect)
  // deps就是 一个与当前副作用函数存在关联的依赖集合
  // 将其添加到activeEffect.deps数组中
  activeEffect.deps.push(deps)
}

function cleanup(effectFn) {
  for (let i = 0; i < effectFn.deps; i++) {
    // deps是依赖集合
    const deps = effectFn.deps[i]
    // 将effectFn从依赖中移除
    deps.delete(effectFn)
  }
  // 最后重置effectFn.deps数组
  effectFn.deps.length = 0
}
```

这里还有个 Set 集合问题。trigger 函数内部遍历了 effects 集合，里面存储着副作用函数。当副作用函数执行的时候，会调用 cleanup 清除（实际上就是用 effects 集合中剔除当前 effect），但副作用执行会导致其重新被收集到集合中，会导致无限循环。类似下面代码：

```js
const set = new Set([1])
set.forEach((item) => {
  set.delete(1)
  set.add(1)
  console.log('遍历中') // 无限循环
})

//解决
const newSet = new Set(set)
newSet.forEach((item) => {
  set.delete(1)
  set.add(1)
  console.log('遍历中') // 不会无限循环
})

// trigger改为：
function trigger(target, key) {
  // 根据target找到对应的depsMap, key -> effects
  const depsMap = bucket.get(target)
  if (!depsMap) return
  // 根据key取得所有副作用函数effects
  const effects = depsMap.get(key)

  const effectsToRun = new Set(effects)
  // 执行副作用函数
  effectsToRun.forEach((effectFn) => effectFn())
}
```

## 嵌套的 effect 与 effect 栈

```js
// effectFn1嵌套了effectFn2
effect(function effectFn1() {
  console.log('effectFn1 执行')
  effect(function effectFn2() {
    console.log('effectFn2 执行')
    // 在effectFn2中读取obj.bar属性
    temp2 = obj.bar
  })
  // 在effectFn1中读取obj.foo属性
  temp1 = obj.foo
})
```
