# 浏览器地址栏输入 url 回车后发生了什么？

![从输入 URL 到页面展示完整流程示意图](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

## 用户输入

- 地址栏会判断输入的`关键字`是`搜索内容`，还是`请求的URL`。如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
- 离开页面之前会触发当前页面的`beforeunload`事件。beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。
- 网站图标进入加载状态，等待提交文档阶段，页面内容才会被替换。

## URL 请求过程

- 浏览器进程通过进程间通信（IPC）把 URL 请求发送至`网络进程`，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。
- 网络进程会查找`本地缓存`是否缓存了该资源(`304`)。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入`网络请求流程`。这请求前的第一步是要进行 `DNS 解析`，以获取请求域名的服务器 `IP 地址`。如果请求协议是 `HTTPS`，那么还需要建立 `TLS 连接`。
- 接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会`构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中`，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等`网络进程接收了响应行和响应头`之后，就开始`解析响应头`的内容了。
  - `重定向`。在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 `301 或者 302`，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 `Location 字段里面读取重定向的地址`，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了
  - `响应数据类型处理`。`Content-Type` 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的`响应体数据是什么类型`.如果 Content-Type 字段的值被浏览器判断为`下载类型`，那么该请求会被提交给浏览器的`下载管理器`，同时该 URL 请求的导航流程就此结束。但如果是 `HTML`，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在`渲染进程`中的，所以接下来就需要准备渲染进程了。

## 渲染准备

- 默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下（同域名下），浏览器会让多个页面直接运行在同一个渲染进程中。
- 渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段
- 所谓提交文档，就是指`浏览器进程`将`网络进程`接收到的 `HTML 数据`提交给`渲染进程`，具体流程是这样的：
  - 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
  - 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
  - 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
  - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

## 渲染过程

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

- 浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 `DOM 树`结构；
- 生成 DOM 树后，还需要根据 CSS 样式表(css 转为浏览器识别的`stylesheet`)，来计算出 DOM 树所有节点的样式；
- 最后计算 DOM 元素的布局信息，使其都保存在布局树中。

  ![布局树构造过程示意图](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png)

- `分层`。页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，`渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）`

  通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

  - `第一点，拥有层叠上下文属性的元素会被提升为单独的一层。`
  - `第二点，需要剪裁（clip）的地方也会被创建为图层。`

- `图层绘制`。在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。
- `栅格化操作`。绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。`合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图`。通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

![完整的渲染流水线示意图](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

总结渲染过程：

- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 参考

[李兵·浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)
